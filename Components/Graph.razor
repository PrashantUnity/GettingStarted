@page "/graph"
<MudPaper Class="d-flex justify-center flex-grow-1 gap-4" Elevation="0">
    <MudPaper Class="pa-6 mx-lg-auto mud-theme-success justify-center" Width="80%">
        <MudSlider @bind-Value="@horizontal" Min="5" Max="15" @onchange="ReGenerate" Disabled="@isSorting">Row Count: @horizontal.ToString()</MudSlider>
            <MudSlider @bind-Value="@vertical" Min="5" Max="40" @onchange="ReGenerate" Disabled="@isSorting">Column Count: @vertical.ToString()</MudSlider>
        <MudSlider @bind-Value="@sleep" Min="1" Max="1000">Delay: @sleep.ToString()</MudSlider>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" OnClick="BFS" Disabled="@isSorting">Depth First Search</MudButton>
        @*  <MudButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" OnClick="DFS" Disabled="@isSorting">Breadth First Search</MudButton> *@
        <MudButton Variant="Variant.Filled" Color="Color.Error" FullWidth="true" OnClick="Reset" Disabled="@isSorting">Reset</MudButton>
    </MudPaper>
</MudPaper>
    @if (graph.Count > 0)
    { 

        <table class="overflow-auto" style="margin: 8px auto; border-color:black; border-width:thick">
                @foreach (var item in graph)
                {
                    <tr>
                        @foreach (var data in item)
                        {
                            <GraphCell BackgroundColorData="@data" OnEmployeeSelection="UpdateGraphData" />
                        }
                    </tr>
                }
            </table>  
    }
@code {



    List<List<GraphCellModels>> graph = new();
    int horizontal = 5;
    int vertical = 7;
    int sleep = 10;
    Random random = new Random();
    GraphCellModels start;
    GraphCellModels end;
    int count = 0;
    bool isSorting = false;


    protected override async Task OnInitializedAsync()
    {
        ReGenerate();
        StateHasChanged();
    }

    protected void UpdateGraphData(GraphCellModels models)
    {
        if (count >= 2) return;
        if (start != null && models.XAxis == start.XAxis && models.YAxis == start.YAxis) return;
        if (models.CellColor == "black") return;
        if (start is null)
        {
            models.CellColor = "green";
            start = models;
        }
        else
        {
            models.CellColor = "blue";
            end = models;
        }
        count++;
        StateHasChanged();
    }
    public void Reset()
    {
        start = null;
        end = null;
        count = 0; 
        isSorting = false;
        foreach (var item in graph)
        {
            foreach (var data in item)
            {
                if (data.CellColor == "yellow" || data.CellColor == "green" || data.CellColor == "blue" || data.CellColor == "red")
                {
                    data.CellColor = "white";
                }
            }
        }
        StateHasChanged();
    }
    public async void BFS()
    {
        isSorting = true;
        if (count <= 1 || start is null || end is null)
        {
            isSorting = false;
            return;
        }

        bool[,] visited = new bool[horizontal, vertical];

        var queue = new Queue<GraphCellModels>();

        queue.Enqueue(start);
        var current = start;
        visited[start.XAxis, start.YAxis] = true;
        var neighbour = new List<(int, int)>
        {
            (-1,0),
            (1,0),
            (0,1),
            (0,-1)
        };
        bool destinationFound = false;
        while (queue.Count > 0)
        {
            current = queue.Dequeue();

            foreach (var item in neighbour)
            {
                var x = current.XAxis + item.Item1;
                var y = current.YAxis + item.Item2;
                if (x >= 0 && y >= 0
                    && x < horizontal && y < vertical
                    && !visited[x, y] && graph[x][y].CellColor != "black")
                {

                    if (graph[x][y].CellColor == "blue")
                    {
                        destinationFound = true;
                        queue.Clear();
                        break;
                    }
                    if (graph[x][y].CellColor != "green")
                        graph[x][y].CellColor = "yellow";
                    visited[x, y] = true;
                    graph[x][y].Parent = current;
                    queue.Enqueue(graph[x][y]);
                    StateHasChanged();
                    await Task.Delay(sleep);
                }
            }
        }

        if (!destinationFound)
        { 
            start = null;
            end = null; 
            isSorting = false;
            StateHasChanged();
            return;
        }
        var parentTrace = new HashSet<GraphCellModels>();
        while (current.Parent != null && parentTrace.Add(current))
        {

            current.CellColor = "red";
            current = current.Parent;
            StateHasChanged();
            await Task.Delay(sleep);
            if (current == start) break;
        }
        start = null;
        end = null; 
        isSorting = false;
        StateHasChanged();
    }
    public async void DFS()
    {
        isSorting = true;
        if (count <= 1 || start is null || end is null) return;

        bool[,] visited = new bool[horizontal, vertical];

        var queue = new Stack<GraphCellModels>();

        queue.Push(start);
        var current = start;
        visited[start.XAxis, start.YAxis] = true;
        var neighbour = new List<(int, int)>
        {
            (-1,0),
            (1,0),
            (0,1),
            (0,-1)
        };

        while (queue.Count > 0)
        {
            current = queue.Pop();

            foreach (var item in neighbour)
            {
                var x = current.XAxis + item.Item1;
                var y = current.YAxis + item.Item2;
                if (x >= 0 && y >= 0
                    && x < horizontal && y < vertical
                    && !visited[x, y] && graph[x][y].CellColor != "black")
                {

                    if (graph[x][y].CellColor == "blue")
                    {
                        queue.Clear();
                        break;
                    }
                    if (graph[x][y].CellColor != "green")
                        graph[x][y].CellColor = "yellow";
                    visited[x, y] = true;
                    queue.Push(graph[x][y]);
                    StateHasChanged();
                    await Task.Delay(sleep);
                }
            }
        }
        while (current.Parent != null)
        {
            current.CellColor = "red";
            current = current.Parent;
            StateHasChanged();
            await Task.Delay(sleep);
        }
        start = null;
        end = null;
        count = 0;
        isSorting = false;
        StateHasChanged();
    }
    void ReGenerate()
    {
        isSorting = false;
        graph.Clear();
        for (int i = 0; i < horizontal; i++)
        {
            var ls = new List<GraphCellModels>();
            for (int j = 0; j < vertical; j++)
            {
                var cellChora = new GraphCellModels()
                    {
                        XAxis = i,
                        YAxis = j
                    };
                if (random.Next(1, 100) > 80) cellChora.CellColor = "black";
                else cellChora.CellColor = "white";
                ls.Add(cellChora);
            }
            graph.Add(ls);
        } 
        start = null;
        end = null;
        count = 0; 
        StateHasChanged();
    }
}
